## 1 0-1 배낭문제와 동적계획법
Description

교재의 내용과 강의자료를 참고하여 0-1 배낭문제를 해결하는 알고리즘의 구현을 완성하시오.

강의자료에서 knapsack2() 또는 knapsack3()를 참조할 것.



단, 입력값은 단위 무게당 이익의 순서로 정렬되어 있지 않음에 유의하시오.

또한,알고리즘 실행 결과의 출력은 알고리즘의 실행과정에서결과 테이블 P에 저장한

무게(i) 또는 이익(j)이 0이 아닌 모든 항목 P[i][j]를 (i, j)의 오름차순으로 모두 출력한다는 것에 주의하시오.


Input
첫 번째 줄에 아이템의 개수 n이 주어진다.

두 번째 줄에 n개의 무게 w[i]가 주어진다.

세 번째 줄에 n개의 이익 p[i]가 주어진다.

네 번째 줄에 배낭 무게의 개수 T가 주어진다.

이후로 T개의 줄에 한 줄에 하나씩 배낭 무게 W가 주어진다.


Output
주어진 배낭 무게 W 각각에 대해 다음과 같이 출력한다.

첫 줄에 최대 이익 maxprofit을 출력한다.

이후로 알고리즘의 실행과정에서 결과 테이블 P에 저장한

무게(i) 또는 이익(j)이 0이 아닌모든 항목 P[i][j]를 (i, j)의 오름차순으로 모두 출력한다


Sample Input 1 

3
5 10 20
50 60 140
1
30
Sample Output 1

200
1 10 50
1 20 50
1 30 50
2 20 140
2 30 190
3 30 200
Sample Input 2 

4
2 5 10 5
40 30 50 10
4
8
16
20
25
Sample Output 2

70
1 3 40
1 8 40
2 3 40
2 8 70
3 3 40
3 8 70
4 8 70
90
1 1 0
1 6 40
1 11 40
1 16 40
2 1 0
2 6 40
2 11 70
2 16 70
3 11 70
3 16 90
4 16 90
120
1 5 40
1 10 40
1 15 40
1 20 40
2 5 40
2 10 70
2 15 70
2 20 70
3 15 90
3 20 120
4 20 120
130
1 5 40
1 10 40
1 15 40
1 20 40
1 25 40
2 10 70
2 15 70
2 20 70
2 25 70
3 20 120
3 25 120
4 25 130

## 2 0-1 배낭문제와 백트래킹
Description

교재와 강의자료를 참고하여 0-1 배낭문제를 해결하는 Algorithm 5.7을 완성하시오.



단, 문제의 입력은 단위무게당 이익순으로 정렬되어 있지 않음에 유의하시오.

또한, 알고리즘의 출력은 알고리즘의 실행 단계별로

상태공간트리의 각 노드에서의 상태를 출력해야 함에 주의하시오.


Input
첫번째 줄에 아이템의 개수 n과 배낭의 무게 W가 주어진다.

두번째 줄에 n개의 아이템 무게 w[i]가 주어진다.

세번째 줄에 n개의 아이템 이익 p[i]가 주어진다.


Output
첫 번째 줄부터 한 줄에 하나씩 상태공간트리를 방문하는 노드의 상태를 출력하시오.

노드 상태는 다음과 같은 순서로 출력한다.

i weight profit bound maxprofit

상태를 출력하는 순서는 Algorithm 5.7의 노드 실행 순서이다. (즉, DFS with Pruning의 노드 순회 순서임)

노드의 상태 출력이 끝나는 다음 줄에 최대이익을 출력한다.

이후로 배낭에 담은 아이템을 한 줄에 하나씩 무게와 이익 순서로 출력한다.

아이템을 출력하는 순서는 처음에 단위무게당 이익으로 정렬한 순서대로 출력함에 주의할 것.


Sample Input 1 

4 16
2 5 10 5
40 30 50 10
Sample Output 1

0 0 0 115 0
1 2 40 115 40
2 7 70 115 70
3 17 120 115 70
3 7 70 80 70
4 12 80 80 80
4 7 70 70 80
2 2 40 98 80
3 12 90 98 90
4 17 100 98 90
4 12 90 90 90
3 2 40 50 90
1 0 0 82 90
90
2 40
10 50
Sample Input 2 

4 16
5 2 5 10
30 40 10 50
Sample Output 2

0 0 0 115 0
1 2 40 115 40
2 7 70 115 70
3 17 120 115 70
3 7 70 80 70
4 12 80 80 80
4 7 70 70 80
2 2 40 98 80
3 12 90 98 90
4 17 100 98 90
4 12 90 90 90
3 2 40 50 90
1 0 0 82 90
90
2 40
10 50

## 3 기사의 여행 문제와 해밀턴 경로
Description

n by m 체스보드에서 기사의 여행 문제를 해결하는 백트래킹 알고리즘을 구현하시오.



Knight's Tour 문제는 해밀턴 경로(path)와 해밀턴 회로(circuit, cycle)를 찾는 문제로 구분할 수 있다.

해밀턴 회로는 출발 정점과 무관하게 회로의 수를 구할 수 있고,

해밀턴 경로는 출발 정점에 따라 가능한 경로의 수가 달라짐에 유의하시오.


Input
첫 번째 줄에 체스보드의 크기 n(행의 크기)과 m(열의 크기)이 주어진다.

두 번째 줄에 출발정점의 개수 T가 주어진다.

이후로 T개의 출발정점이 i(row), j(col) 의 쌍으로 주어진다.


Output
첫 번째 줄에 해밀턴 회로의 개수를 출력한다.

두 번째 줄부터 입력에서 주어진 출발정점 각각에 대해 해밀턴 경로의 수를 한 줄에 하나씩 출력한다.


Sample Input 1 

3 4
3
0 0
0 1
1 0
Sample Output 1

0
2
0
4
Sample Input 2 

3 10
2
0 0
1 1
Sample Output 2

32
448
416